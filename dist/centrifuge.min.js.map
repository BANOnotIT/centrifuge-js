{"version":3,"file":"centrifuge.min.js","mappings":"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","sources":["webpack://Centrifuge/webpack/universalModuleDefinition","webpack://Centrifuge/./src/centrifuge.js","webpack://Centrifuge/./src/index.js","webpack://Centrifuge/./src/json.js","webpack://Centrifuge/./src/subscription.js","webpack://Centrifuge/./src/utils.js","webpack://Centrifuge/./node_modules/events/events.js","webpack://Centrifuge/webpack/bootstrap","webpack://Centrifuge/webpack/runtime/global","webpack://Centrifuge/webpack/startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Centrifuge\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Centrifuge\"] = factory();\n\telse\n\t\troot[\"Centrifuge\"] = factory();\n})(this, function() {\nreturn ","import EventEmitter from 'events';\nimport Subscription from './subscription';\n\nimport {\n  JsonEncoder,\n  JsonDecoder,\n  JsonMethodType,\n  JsonPushType\n} from './json';\n\nimport {\n  isFunction,\n  log,\n  startsWith,\n  errorExists,\n  backoff,\n  extend\n} from './utils';\n\nconst _errorTimeout = 'timeout';\nconst _errorConnectionClosed = 'connection closed';\n\nexport class Centrifuge extends EventEmitter {\n\n  constructor(url, options) {\n    super();\n    this._url = url;\n    this._websocket = null;\n    this._sockjs = null;\n    this._isSockjs = false;\n    this._xmlhttprequest = null;\n    this._binary = false;\n    this._methodType = null;\n    this._pushType = null;\n    this._encoder = null;\n    this._decoder = null;\n    this._status = 'disconnected';\n    this._reconnect = true;\n    this._reconnecting = false;\n    this._transport = null;\n    this._transportName = null;\n    this._transportClosed = true;\n    this._messageId = 0;\n    this._clientID = null;\n    this._refreshRequired = false;\n    this._subs = {};\n    this._serverSubs = {};\n    this._lastSeq = {};\n    this._lastGen = {};\n    this._lastOffset = {};\n    this._lastEpoch = {};\n    this._messages = [];\n    this._isBatching = false;\n    this._isSubscribeBatching = false;\n    this._privateChannels = {};\n    this._numRefreshFailed = 0;\n    this._refreshTimeout = null;\n    this._pingTimeout = null;\n    this._pongTimeout = null;\n    this._subRefreshTimeouts = {};\n    this._retries = 0;\n    this._callbacks = {};\n    this._latency = null;\n    this._latencyStart = null;\n    this._connectData = null;\n    this._token = null;\n    this._xhrID = 0;\n    this._xhrs = {};\n    this._dispatchPromise = Promise.resolve();\n    this._protocol = '';\n    this._config = {\n      protocol: '',\n      protocolVersion: 'v1',\n      debug: false,\n      name: 'js',\n      version: '',\n      websocket: null,\n      sockjs: null,\n      xmlhttprequest: null,\n      minRetry: 1000,\n      maxRetry: 20000,\n      timeout: 5000,\n      ping: true,\n      pingInterval: 25000,\n      pongWaitTimeout: 5000,\n      privateChannelPrefix: '$',\n      onTransportClose: null,\n      sockjsServer: null,\n      sockjsTimeout: null,\n      sockjsTransports: [\n        'websocket',\n        'xdr-streaming',\n        'xhr-streaming',\n        'eventsource',\n        'iframe-eventsource',\n        'iframe-htmlfile',\n        'xdr-polling',\n        'xhr-polling',\n        'iframe-xhr-polling',\n        'jsonp-polling'\n      ],\n      refreshEndpoint: '/centrifuge/refresh',\n      refreshHeaders: {},\n      refreshParams: {},\n      refreshData: {},\n      refreshAttempts: null,\n      refreshInterval: 1000,\n      onRefreshFailed: null,\n      onRefresh: null,\n      subscribeEndpoint: '/centrifuge/subscribe',\n      subscribeHeaders: {},\n      subscribeParams: {},\n      subRefreshInterval: 1000,\n      onPrivateSubscribe: null,\n      disableWithCredentials: false\n    };\n    this._configure(options);\n  }\n\n  setToken(token) {\n    this._token = token;\n  }\n\n  setConnectData(data) {\n    this._connectData = data;\n  }\n\n  setRefreshHeaders(headers) {\n    this._config.refreshHeaders = headers;\n  }\n\n  setRefreshParams(params) {\n    this._config.refreshParams = params;\n  }\n\n  setRefreshData(data) {\n    this._config.refreshData = data;\n  }\n\n  setSubscribeHeaders(headers) {\n    this._config.subscribeHeaders = headers;\n  }\n\n  setSubscribeParams(params) {\n    this._config.subscribeParams = params;\n  }\n\n  _ajax(url, params, headers, data, callback) {\n    let query = '';\n    this._debug('sending AJAX request to', url, 'with data', JSON.stringify(data));\n\n    let xhr;\n    if (this._xmlhttprequest !== null) {\n      // use explicitly passed XMLHttpRequest object.\n      xhr = new this._xmlhttprequest();\n    } else {\n      xhr = (global.XMLHttpRequest ? new global.XMLHttpRequest() : new global.ActiveXObject('Microsoft.XMLHTTP'));\n    }\n\n    for (const i in params) {\n      if (params.hasOwnProperty(i)) {\n        if (query.length > 0) {\n          query += '&';\n        }\n        query += encodeURIComponent(i) + '=' + encodeURIComponent(params[i]);\n      }\n    }\n    if (query.length > 0) {\n      query = '?' + query;\n    }\n    xhr.open('POST', url + query, true);\n    if ('withCredentials' in xhr) {\n      xhr.withCredentials = !this._config.disableWithCredentials;\n    }\n\n    xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');\n    xhr.setRequestHeader('Content-Type', 'application/json');\n    for (const headerName in headers) {\n      if (headers.hasOwnProperty(headerName)) {\n        xhr.setRequestHeader(headerName, headers[headerName]);\n      }\n    }\n\n    xhr.onreadystatechange = () => {\n      if (xhr.readyState === 4) {\n        if (xhr.status === 200) {\n          let data, parsed = false;\n          try {\n            data = JSON.parse(xhr.responseText);\n            parsed = true;\n          } catch (e) {\n            callback({\n              error: 'Invalid JSON. Data was: ' + xhr.responseText,\n              status: 200,\n              data: null\n            });\n          }\n          if (parsed) { // prevents double execution.\n            callback({\n              data: data,\n              status: 200\n            });\n          }\n        } else {\n          this._log('wrong status code in AJAX response', xhr.status);\n          callback({\n            status: xhr.status,\n            data: null\n          });\n        }\n      }\n    };\n    setTimeout(() => xhr.send(JSON.stringify(data)), 20);\n    return xhr;\n  };\n\n  _log() {\n    log('info', arguments);\n  };\n\n  _debug() {\n    if (this._config.debug === true) {\n      log('debug', arguments);\n    }\n  };\n\n  _websocketSupported() {\n    if (this._config.websocket !== null) {\n      return true;\n    }\n    return !(typeof WebSocket !== 'function' && typeof WebSocket !== 'object');\n  };\n\n  _setFormat(format) {\n    if (this._formatOverride(format)) {\n      return;\n    }\n    if (format === 'protobuf') {\n      throw new Error('not implemented by JSON only Centrifuge client – use client with Protobuf');\n    }\n    this._binary = false;\n    this._methodType = JsonMethodType;\n    this._pushType = JsonPushType;\n    this._encoder = new JsonEncoder();\n    this._decoder = new JsonDecoder();\n  }\n\n  _formatOverride(format) {\n    return false;\n  }\n\n  _configure(configuration) {\n    if (!('Promise' in global)) {\n      throw new Error('Promise polyfill required');\n    }\n\n    extend(this._config, configuration || {});\n    this._debug('centrifuge config', this._config);\n\n    if (!this._url) {\n      throw new Error('url required');\n    }\n\n    const isProtobufURL = startsWith(this._url, 'ws') && this._url.indexOf('format=protobuf') > -1;\n    if (isProtobufURL || this._config.protocol === 'protobuf') {\n      this._setFormat('protobuf');\n      this._protocol = 'protobuf';\n    } else {\n      if (this._config.protocol !== '' && this._config.protocol !== 'json') {\n        throw new Error('unsupported protocol ' + this._config.protocol);\n      }\n      this._setFormat('json');\n    }\n\n    if (this._config.protocolVersion !== 'v1' && this._config.protocolVersion !== 'v2') {\n      throw new Error('unsupported protocol version ' + this._config.protocolVersion);\n    }\n\n    if (startsWith(this._url, 'http')) {\n      this._debug('client will try to connect to SockJS endpoint');\n      if (this._config.sockjs !== null) {\n        this._debug('SockJS explicitly provided in options');\n        this._sockjs = this._config.sockjs;\n      } else {\n        if (typeof global.SockJS === 'undefined') {\n          throw new Error('SockJS not found, use ws:// in url or include SockJS');\n        }\n        this._debug('use globally defined SockJS');\n        this._sockjs = global.SockJS;\n      }\n    } else {\n      this._debug('client will connect to websocket endpoint');\n    }\n\n    this._xmlhttprequest = this._config.xmlhttprequest;\n  };\n\n  _setStatus(newStatus) {\n    if (this._status !== newStatus) {\n      this._debug('Status', this._status, '->', newStatus);\n      this._status = newStatus;\n    }\n  };\n\n  _isDisconnected() {\n    return this._status === 'disconnected';\n  };\n\n  _isConnecting() {\n    return this._status === 'connecting';\n  };\n\n  _isConnected() {\n    return this._status === 'connected';\n  };\n\n  _nextMessageId() {\n    return ++this._messageId;\n  };\n\n  _resetRetry() {\n    this._debug('reset retries count to 0');\n    this._retries = 0;\n  };\n\n  _getRetryInterval() {\n    const interval = backoff(this._retries, this._config.minRetry, this._config.maxRetry);\n\n    this._retries += 1;\n    return interval;\n  };\n\n  _abortInflightXHRs() {\n    for (const xhrID in this._xhrs) {\n      try {\n        this._xhrs[xhrID].abort();\n      } catch (e) {\n        this._debug('error aborting xhr', e);\n      }\n      delete this._xhrs[xhrID];\n    }\n  };\n\n  _clearConnectedState(reconnect) {\n    this._clientID = null;\n    this._stopPing();\n\n    // fire errbacks of registered outgoing calls.\n    for (const id in this._callbacks) {\n      if (this._callbacks.hasOwnProperty(id)) {\n        const callbacks = this._callbacks[id];\n        clearTimeout(callbacks.timeout);\n        const errback = callbacks.errback;\n        if (!errback) {\n          continue;\n        }\n        errback({ error: this._createErrorObject('disconnected') });\n      }\n    }\n    this._callbacks = {};\n\n    // fire unsubscribe events\n    for (const channel in this._subs) {\n      if (this._subs.hasOwnProperty(channel)) {\n        const sub = this._subs[channel];\n\n        if (reconnect) {\n          if (sub._isSuccess()) {\n            sub._triggerUnsubscribe();\n            sub._recover = true;\n          }\n          if (sub._shouldResubscribe()) {\n            sub._setSubscribing();\n          }\n        } else {\n          sub._setUnsubscribed();\n        }\n      }\n    }\n\n    this._abortInflightXHRs();\n\n    // clear refresh timer\n    if (this._refreshTimeout !== null) {\n      clearTimeout(this._refreshTimeout);\n      this._refreshTimeout = null;\n    }\n\n    // clear sub refresh timers\n    for (const channel in this._subRefreshTimeouts) {\n      if (this._subRefreshTimeouts.hasOwnProperty(channel) && this._subRefreshTimeouts[channel]) {\n        this._clearSubRefreshTimeout(channel);\n      }\n    }\n    this._subRefreshTimeouts = {};\n\n    if (!this._reconnect) {\n      // completely clear subscriptions\n      this._subs = {};\n    }\n  };\n\n  _isTransportOpen() {\n    if (this._isSockjs) {\n      return this._transport &&\n        this._transport.transport &&\n        this._transport.transport.readyState === this._transport.transport.OPEN;\n    }\n    return this._transport && this._transport.readyState === this._transport.OPEN;\n  };\n\n  _transportSend(commands) {\n    if (!commands.length) {\n      return true;\n    }\n\n    if (!this._isTransportOpen()) {\n      // resolve pending commands with error if transport is not open\n      for (let command in commands) {\n        let id = command.id;\n        if (!(id in this._callbacks)) {\n          continue;\n        }\n        const callbacks = this._callbacks[id];\n        clearTimeout(this._callbacks[id].timeout);\n        delete this._callbacks[id];\n        const errback = callbacks.errback;\n        errback({ error: this._createErrorObject(_errorConnectionClosed, 0) });\n      }\n      return false;\n    }\n    this._transport.send(this._encoder.encodeCommands(commands));\n    return true;\n  }\n\n  _getSubProtocol() {\n    if (!this._protocol) {\n      return '';\n    }\n    return 'centrifuge-' + this._protocol;\n  }\n\n  _setupTransport() {\n    this._isSockjs = false;\n\n    // detect transport to use - SockJS or Websocket\n    if (this._sockjs !== null) {\n      const sockjsOptions = {\n        transports: this._config.sockjsTransports\n      };\n\n      if (this._config.sockjsServer !== null) {\n        sockjsOptions.server = this._config.sockjsServer;\n      }\n      if (this._config.sockjsTimeout !== null) {\n        sockjsOptions.timeout = this._config.sockjsTimeout;\n      }\n      this._isSockjs = true;\n      this._transport = new this._sockjs(this._url, null, sockjsOptions);\n    } else {\n      if (!this._websocketSupported()) {\n        this._debug('No Websocket support and no SockJS configured, can not connect');\n        return;\n      }\n      if (this._config.websocket !== null) {\n        this._websocket = this._config.websocket;\n      } else {\n        this._websocket = WebSocket;\n      }\n      const subProtocol = this._getSubProtocol();\n      if (subProtocol !== '') {\n        this._transport = new this._websocket(this._url, subProtocol);\n      } else {\n        this._transport = new this._websocket(this._url);\n      }\n      if (this._binary === true) {\n        this._transport.binaryType = 'arraybuffer';\n      }\n    }\n\n    this._transport.onopen = () => {\n      this._transportClosed = false;\n\n      if (this._isSockjs) {\n        this._transportName = 'sockjs-' + this._transport.transport;\n        this._transport.onheartbeat = () => this._restartPing();\n      } else {\n        this._transportName = 'websocket';\n      }\n\n      const req = {};\n\n      if (this._token) {\n        req.token = this._token;\n      }\n      if (this._connectData) {\n        req.data = this._connectData;\n      }\n      if (this._config.name) {\n        req.name = this._config.name;\n      }\n      if (this._config.version) {\n        req.version = this._config.version;\n      }\n\n      let subs = {};\n      let hasSubs = false;\n      for (const channel in this._serverSubs) {\n        if (this._serverSubs.hasOwnProperty(channel) && this._serverSubs[channel].recoverable) {\n          hasSubs = true;\n          let sub = {\n            'recover': true\n          };\n          if (this._serverSubs[channel].seq || this._serverSubs[channel].gen) {\n            if (this._serverSubs[channel].seq) {\n              sub['seq'] = this._serverSubs[channel].seq;\n            }\n            if (this._serverSubs[channel].gen) {\n              sub['gen'] = this._serverSubs[channel].gen;\n            }\n          } else {\n            if (this._serverSubs[channel].offset) {\n              sub['offset'] = this._serverSubs[channel].offset;\n            }\n          }\n          if (this._serverSubs[channel].epoch) {\n            sub['epoch'] = this._serverSubs[channel].epoch;\n          }\n          subs[channel] = sub;\n        }\n      }\n      if (hasSubs) {\n        req.subs = subs;\n      }\n\n      this._latencyStart = new Date();\n\n      const msg = {};\n      if (this._config.protocolVersion === 'v2') {\n        msg.connect = req;\n      } else {\n        // Can omit CONNECT method here due to zero value.\n        msg.params = req;\n      }\n\n      this._call(msg).then(resolveCtx => {\n        let result;\n        if (this._config.protocolVersion === 'v1') {\n          result = this._decoder.decodeCommandResult(this._methodType.CONNECT, resolveCtx.reply.result);\n        } else {\n          result = resolveCtx.reply.connect;\n        }\n        this._connectResponse(result, hasSubs);\n        if (resolveCtx.next) {\n          resolveCtx.next();\n        }\n      }, rejectCtx => {\n        const err = rejectCtx.error;\n        if (err.code === 109) { // token expired.\n          this._refreshRequired = true;\n        }\n        this._disconnect(6, 'connect error', true);\n        if (rejectCtx.next) {\n          rejectCtx.next();\n        }\n      });\n    };\n\n    this._transport.onerror = error => {\n      this._debug('transport level error', error);\n    };\n\n    this._transport.onclose = closeEvent => {\n      this._transportClosed = true;\n      let reason = _errorConnectionClosed;\n      let needReconnect = true;\n      let code = 0;\n\n      if (closeEvent && 'code' in closeEvent && closeEvent.code) {\n        code = closeEvent.code;\n      }\n\n      if (closeEvent && 'reason' in closeEvent && closeEvent.reason) {\n        try {\n          const advice = JSON.parse(closeEvent.reason);\n          reason = advice.reason;\n          needReconnect = advice.reconnect;\n        } catch (e) {\n          reason = closeEvent.reason;\n          if ((code >= 3500 && code < 4000) || (code >= 4500 && code < 5000)) {\n            needReconnect = false;\n          }\n        }\n      }\n\n      if (code < 3000) {\n        code = 4;\n        reason = 'connection closed';\n      }\n\n      // onTransportClose callback should be executed every time transport was closed.\n      // This can be helpful to catch failed connection events (because our disconnect\n      // event only called once and every future attempts to connect do not fire disconnect\n      // event again).\n      if (this._config.onTransportClose !== null) {\n        const ctx = {\n          event: closeEvent,\n          reason: reason,\n          reconnect: needReconnect\n        };\n        if (this._config.protocolVersion === 'v2') {\n          ctx['code'] = code;\n        }\n        this._config.onTransportClose(ctx);\n      }\n\n      this._disconnect(code, reason, needReconnect);\n\n      if (this._reconnect === true) {\n        this._reconnecting = true;\n        const interval = this._getRetryInterval();\n\n        this._debug('reconnect after ' + interval + ' milliseconds');\n        setTimeout(() => {\n          if (this._reconnect === true) {\n            if (this._refreshRequired) {\n              this._refresh();\n            } else {\n              this._connect();\n            }\n          }\n        }, interval);\n      }\n    };\n\n    this._transport.onmessage = event => {\n      this._dataReceived(event.data);\n    };\n  };\n\n  rpc(data) {\n    return this._rpc('', data);\n  }\n\n  namedRPC(method, data) {\n    return this._rpc(method, data);\n  }\n\n  _rpc(method, data) {\n    const req = {\n      data: data\n    };\n    if (method !== '') {\n      req.method = method;\n    };\n    const msg = {};\n    if (this._config.protocolVersion === 'v2') {\n      msg.rpc = req;\n    } else {\n      msg.method = this._methodType.RPC;\n      msg.params = req;\n    }\n    let self = this;\n    return this._methodCall(msg, function (reply) {\n      let result;\n      if (self._config.protocolVersion === 'v1') {\n        result = self._decoder.decodeCommandResult(self._methodType.RPC, reply.result);\n      } else {\n        result = reply.rpc;\n      }\n      return {\n        'data': result.data\n      };\n    });\n  }\n\n  send(data) {\n    const req = {\n      data: data\n    };\n    const msg = {};\n    if (this._config.protocolVersion === 'v2') {\n      msg.send = req;\n    } else {\n      msg.method = this._methodType.SEND;\n      msg.params = req;\n    }\n\n    if (!this.isConnected()) {\n      return Promise.reject(this._createErrorObject(_errorConnectionClosed, 0));\n    }\n\n    const sent = this._transportSend([msg]); // can send async message to server without id set\n    if (!sent) {\n      return Promise.reject(this._createErrorObject(_errorConnectionClosed, 0));\n    };\n    return Promise.resolve({});\n  }\n\n  _getHistoryRequest(channel, options) {\n    let params = {\n      channel: channel\n    };\n    if (options !== undefined) {\n      if (options.since) {\n        params['since'] = {\n          'offset': options.since.offset\n        };\n        if (options.since.epoch) {\n          params['since']['epoch'] = options.since.epoch;\n        }\n      };\n      if (options.limit !== undefined) {\n        params['limit'] = options.limit;\n      }\n      if (options.reverse === true) {\n        params['reverse'] = true;\n      }\n    };\n    return params;\n  }\n\n  _methodCall(msg, resultCB) {\n    if (!this.isConnected()) {\n      return Promise.reject(this._createErrorObject(_errorConnectionClosed, 0));\n    }\n    return new Promise((resolve, reject) => {\n      this._call(msg).then(resolveCtx => {\n        resolve(resultCB(resolveCtx.reply));\n        if (resolveCtx.next) {\n          resolveCtx.next();\n        }\n      }, rejectCtx => {\n        reject(rejectCtx.error);\n        if (rejectCtx.next) {\n          rejectCtx.next();\n        }\n      });\n    });\n  }\n\n  publish(channel, data) {\n    const req = {\n      channel: channel,\n      data: data\n    };\n    const msg = {};\n    if (this._config.protocolVersion === 'v2') {\n      msg.publish = req;\n    } else {\n      msg.method = this._methodType.PUBLISH;\n      msg.params = req;\n    }\n    return this._methodCall(msg, function () {\n      return {};\n    });\n  }\n\n  history(channel, options) {\n    const req = this._getHistoryRequest(channel, options);\n    const msg = {};\n    if (this._config.protocolVersion === 'v2') {\n      msg.history = req;\n    } else {\n      msg.method = this._methodType.HISTORY;\n      msg.params = req;\n    }\n    let self = this;\n    return this._methodCall(msg, function (reply) {\n      let result;\n      if (self._config.protocolVersion === 'v1') {\n        result = self._decoder.decodeCommandResult(self._methodType.HISTORY, reply.result);\n      } else {\n        result = reply.history;\n      }\n      return {\n        'publications': result.publications,\n        'epoch': result.epoch || '',\n        'offset': result.offset || 0\n      };\n    });\n  }\n\n  presence(channel) {\n    const req = {\n      channel: channel\n    };\n    const msg = {};\n    if (this._config.protocolVersion === 'v2') {\n      msg.presence = req;\n    } else {\n      msg.method = this._methodType.PRESENCE;\n      msg.params = req;\n    }\n    let self = this;\n    return this._methodCall(msg, function (reply) {\n      let result;\n      if (self._config.protocolVersion === 'v1') {\n        result = self._decoder.decodeCommandResult(self._methodType.PRESENCE, reply.result);\n      } else {\n        result = reply.presence;\n      }\n      return {\n        'presence': result.presence\n      };\n    });\n  }\n\n  presenceStats(channel) {\n    const req = {\n      channel: channel\n    };\n    const msg = {};\n    if (this._config.protocolVersion === 'v2') {\n      msg['presence_stats'] = req;\n    } else {\n      msg.method = this._methodType.PRESENCE_STATS;\n      msg.params = req;\n    }\n    return this._methodCall(msg, function (reply) {\n      let result;\n      if (self._config.protocolVersion === 'v1') {\n        result = self._decoder.decodeCommandResult(self._methodType.PRESENCE_STATS, reply.result);\n      } else {\n        result = reply.presence_stats;\n      }\n      return {\n        'num_users': result.num_users,\n        'num_clients': result.num_clients\n      };\n    });\n  }\n\n  _dataReceived(data) {\n    const replies = this._decoder.decodeReplies(data);\n    // we have to guarantee order of events in replies processing - i.e. start processing\n    // next reply only when we finished processing of current one. Without syncing things in\n    // this way we could get wrong publication events order as reply promises resolve\n    // on next loop tick so for loop continues before we finished emitting all reply events.\n    this._dispatchPromise = this._dispatchPromise.then(() => {\n      let finishDispatch;\n      this._dispatchPromise = new Promise(resolve => {\n        finishDispatch = resolve;\n      });\n      this._dispatchSynchronized(replies, finishDispatch);\n    });\n    this._restartPing();\n  }\n\n  _dispatchSynchronized(replies, finishDispatch) {\n    let p = Promise.resolve();\n    for (const i in replies) {\n      if (replies.hasOwnProperty(i)) {\n        p = p.then(() => {\n          return this._dispatchReply(replies[i]);\n        });\n      }\n    }\n    p = p.then(() => {\n      finishDispatch();\n    });\n  }\n\n  _dispatchReply(reply) {\n    var next;\n    const p = new Promise(resolve => {\n      next = resolve;\n    });\n\n    if (reply === undefined || reply === null) {\n      this._debug('dispatch: got undefined or null reply');\n      next();\n      return p;\n    }\n\n    const id = reply.id;\n\n    if (id && id > 0) {\n      this._handleReply(reply, next);\n    } else {\n      if (this._config.protocolVersion === 'v1') {\n        this._handlePush(reply.result, next);\n      } else {\n        this._handlePushV2(reply.push, next);\n      }\n    }\n\n    return p;\n  };\n\n  _call(msg) {\n    return new Promise((resolve, reject) => {\n      const id = this._addMessage(msg);\n      this._registerCall(id, resolve, reject);\n    });\n  }\n\n  _connect() {\n    if (this.isConnected()) {\n      this._debug('connect called when already connected');\n      return;\n    }\n    if (this._status === 'connecting') {\n      return;\n    }\n\n    this._debug('start connecting');\n    this._setStatus('connecting');\n    this._clientID = null;\n    this._reconnect = true;\n    this._setupTransport();\n  };\n\n  _disconnect(code, reason, shouldReconnect) {\n    const reconnect = shouldReconnect || false;\n    if (reconnect === false) {\n      this._reconnect = false;\n    }\n\n    if (this._isDisconnected()) {\n      if (!reconnect) {\n        this._clearConnectedState(reconnect);\n      }\n      return;\n    }\n\n    this._clearConnectedState(reconnect);\n\n    this._debug('disconnected:', reason, shouldReconnect);\n    this._setStatus('disconnected');\n\n    if (this._refreshTimeout) {\n      clearTimeout(this._refreshTimeout);\n      this._refreshTimeout = null;\n    }\n    if (this._reconnecting === false) {\n      // fire unsubscribe events for server side subs.\n      for (const channel in this._serverSubs) {\n        if (this._serverSubs.hasOwnProperty(channel)) {\n          this.emit('unsubscribe', { channel: channel });\n        }\n      }\n      const ctx = {\n        reason: reason,\n        reconnect: reconnect\n      };\n      if (this._config.protocolVersion === 'v2') {\n        ctx['code'] = code;\n      }\n      this.emit('disconnect', ctx);\n    }\n\n    if (reconnect === false) {\n      this._subs = {};\n      this._serverSubs = {};\n    }\n\n    if (!this._transportClosed) {\n      this._transport.close();\n    }\n  };\n\n  _refreshFailed() {\n    this._numRefreshFailed = 0;\n    if (!this._isDisconnected()) {\n      this._disconnect(7, 'refresh failed', false);\n    }\n    if (this._config.onRefreshFailed !== null) {\n      this._config.onRefreshFailed();\n    }\n  };\n\n  _refresh() {\n    // ask application for new connection token.\n    this._debug('refresh token');\n\n    if (this._config.refreshAttempts === 0) {\n      this._debug('refresh attempts set to 0, do not send refresh request at all');\n      this._refreshFailed();\n      return;\n    }\n\n    if (this._refreshTimeout !== null) {\n      clearTimeout(this._refreshTimeout);\n      this._refreshTimeout = null;\n    }\n\n    const clientID = this._clientID;\n    const xhrID = this._newXHRID();\n\n    const cb = (resp) => {\n      if (xhrID in this._xhrs) {\n        delete this._xhrs[xhrID];\n      }\n      if (this._clientID !== clientID) {\n        return;\n      }\n      if (resp.error || resp.status !== 200) {\n        // We don't perform any connection status related actions here as we are\n        // relying on server that must close connection eventually.\n        if (resp.error) {\n          this._debug('error refreshing connection token', resp.error);\n        } else {\n          this._debug('error refreshing connection token: wrong status code', resp.status);\n        }\n        this._numRefreshFailed++;\n        if (this._refreshTimeout !== null) {\n          clearTimeout(this._refreshTimeout);\n          this._refreshTimeout = null;\n        }\n        if (this._config.refreshAttempts !== null && this._numRefreshFailed >= this._config.refreshAttempts) {\n          this._refreshFailed();\n          return;\n        }\n        const jitter = Math.round(Math.random() * 1000 * Math.max(this._numRefreshFailed, 20));\n        const interval = this._config.refreshInterval + jitter;\n        this._refreshTimeout = setTimeout(() => this._refresh(), interval);\n        return;\n      }\n      this._numRefreshFailed = 0;\n      this._token = resp.data.token;\n      if (!this._token) {\n        this._refreshFailed();\n        return;\n      }\n      if (this._isDisconnected() && this._reconnect) {\n        this._debug('token refreshed, connect from scratch');\n        this._connect();\n      } else {\n        this._debug('send refreshed token');\n        const req = { token: this._token };\n        const msg = {};\n        if (this._config.protocolVersion === 'v2') {\n          msg.refresh = req;\n        } else {\n          msg.method = this._methodType.REFRESH;\n          msg.params = req;\n        }\n\n        const self = this;\n\n        this._call(msg).then(resolveCtx => {\n          let result;\n          if (self._config.protocolVersion === 'v1') {\n            result = self._decoder.decodeCommandResult(self._methodType.REFRESH, resolveCtx.reply.result);\n          } else {\n            result = resolveCtx.reply.refresh;\n          }\n          this._refreshResponse(result);\n          if (resolveCtx.next) {\n            resolveCtx.next();\n          }\n        }, rejectCtx => {\n          this._refreshError(rejectCtx.error);\n          if (rejectCtx.next) {\n            rejectCtx.next();\n          }\n        });\n      }\n    };\n\n    if (this._config.onRefresh !== null) {\n      const context = {};\n      this._config.onRefresh(context, cb);\n    } else {\n      const xhr = this._ajax(\n        this._config.refreshEndpoint,\n        this._config.refreshParams,\n        this._config.refreshHeaders,\n        this._config.refreshData,\n        cb\n      );\n      this._xhrs[xhrID] = xhr;\n    }\n  };\n\n  _refreshError(err) {\n    this._debug('refresh error', err);\n    if (this._refreshTimeout) {\n      clearTimeout(this._refreshTimeout);\n      this._refreshTimeout = null;\n    }\n    const interval = this._config.refreshInterval + Math.round(Math.random() * 1000);\n    this._refreshTimeout = setTimeout(() => this._refresh(), interval);\n  }\n\n  _refreshResponse(result) {\n    if (this._refreshTimeout) {\n      clearTimeout(this._refreshTimeout);\n      this._refreshTimeout = null;\n    }\n    if (result.expires) {\n      this._clientID = result.client;\n      this._refreshTimeout = setTimeout(() => this._refresh(), this._getTTLMilliseconds(result.ttl));\n    }\n  };\n\n  _newXHRID() {\n    this._xhrID++;\n    return this._xhrID;\n  }\n\n  _subRefresh(channel) {\n    this._debug('refresh subscription token for channel', channel);\n\n    if (this._subRefreshTimeouts[channel] !== undefined) {\n      this._clearSubRefreshTimeout(channel);\n    } else {\n      return;\n    }\n\n    const clientID = this._clientID;\n    const xhrID = this._newXHRID();\n\n    const cb = (resp) => {\n      if (xhrID in this._xhrs) {\n        delete this._xhrs[xhrID];\n      }\n      if (resp.error || resp.status !== 200 || this._clientID !== clientID) {\n        return;\n      }\n      let channelsData = {};\n      if (resp.data.channels) {\n        for (const i in resp.data.channels) {\n          const channelData = resp.data.channels[i];\n          if (!channelData.channel) {\n            continue;\n          }\n          channelsData[channelData.channel] = channelData.token;\n        }\n      }\n\n      const token = channelsData[channel];\n      if (!token) {\n        return;\n      }\n\n      const sub = this._getSub(channel);\n      if (sub === null) {\n        return;\n      }\n\n      const req = {\n        channel: channel,\n        token: token\n      };\n      const msg = {};\n\n      if (this._config.protocolVersion === 'v2') {\n        msg['sub_refresh'] = req;\n      } else {\n        msg.method = this._methodType.SUB_REFRESH;\n        msg.params = req;\n      }\n\n      const self = this;\n\n      this._call(msg).then(resolveCtx => {\n        let result;\n        if (self._config.protocolVersion === 'v1') {\n          result = self._decoder.decodeCommandResult(self._methodType.SUB_REFRESH, resolveCtx.reply.result);\n        } else {\n          result = resolveCtx.reply.sub_refresh;\n        }\n        this._subRefreshResponse(channel, result);\n        if (resolveCtx.next) {\n          resolveCtx.next();\n        }\n      }, rejectCtx => {\n        this._subRefreshError(channel, rejectCtx.error);\n        if (rejectCtx.next) {\n          rejectCtx.next();\n        }\n      });\n    };\n\n    const data = {\n      client: this._clientID,\n      channels: [channel]\n    };\n\n    if (this._config.onPrivateSubscribe !== null) {\n      this._config.onPrivateSubscribe({\n        data: data\n      }, cb);\n    } else {\n      const xhr = this._ajax(\n        this._config.subscribeEndpoint, this._config.subscribeParams, this._config.subscribeHeaders, data, cb);\n      this._xhrs[xhrID] = xhr;\n    }\n  };\n\n  _clearSubRefreshTimeout(channel) {\n    if (this._subRefreshTimeouts[channel] !== undefined) {\n      clearTimeout(this._subRefreshTimeouts[channel]);\n      delete this._subRefreshTimeouts[channel];\n    }\n  }\n\n  _subRefreshError(channel, err) {\n    this._debug('subscription refresh error', channel, err);\n    this._clearSubRefreshTimeout(channel);\n    const sub = this._getSub(channel);\n    if (sub === null) {\n      return;\n    }\n    const jitter = Math.round(Math.random() * 1000);\n    let subRefreshTimeout = setTimeout(() => this._subRefresh(channel), this._config.subRefreshInterval + jitter);\n    this._subRefreshTimeouts[channel] = subRefreshTimeout;\n    return;\n  }\n\n  _subRefreshResponse(channel, result) {\n    this._debug('subscription refresh success', channel);\n    this._clearSubRefreshTimeout(channel);\n    const sub = this._getSub(channel);\n    if (sub === null) {\n      return;\n    }\n    if (result.expires === true) {\n      let subRefreshTimeout = setTimeout(() => this._subRefresh(channel), this._getTTLMilliseconds(result.ttl));\n      this._subRefreshTimeouts[channel] = subRefreshTimeout;\n    }\n    return;\n  };\n\n  _subscribe(sub, isResubscribe) {\n    this._debug('subscribing on', sub.channel);\n    const channel = sub.channel;\n\n    if (!(channel in this._subs)) {\n      this._subs[channel] = sub;\n    }\n\n    if (!this.isConnected()) {\n      // subscribe will be called later\n      sub._setNew();\n      return;\n    }\n\n    sub._setSubscribing(isResubscribe);\n\n    const req = {\n      channel: channel\n    };\n\n    if (sub._subscribeData) {\n      req.data = sub._subscribeData;\n    }\n\n    // If channel name does not start with privateChannelPrefix - then we\n    // can just send subscription message to Centrifuge. If channel name\n    // starts with privateChannelPrefix - then this is a private channel\n    // and we should ask web application backend for permission first.\n    if (startsWith(channel, this._config.privateChannelPrefix)) {\n      // private channel.\n      if (this._isSubscribeBatching) {\n        this._privateChannels[channel] = true;\n      } else {\n        this.startSubscribeBatching();\n        this._subscribe(sub);\n        this.stopSubscribeBatching();\n      }\n    } else {\n      const recover = sub._needRecover();\n\n      if (recover === true) {\n        req.recover = true;\n        const seq = this._getLastSeq(channel);\n        const gen = this._getLastGen(channel);\n        if (seq || gen) {\n          if (seq) {\n            req.seq = seq;\n          }\n          if (gen) {\n            req.gen = gen;\n          }\n        } else {\n          const offset = this._getLastOffset(channel);\n          if (offset) {\n            req.offset = offset;\n          }\n        }\n        const epoch = this._getLastEpoch(channel);\n        if (epoch) {\n          req.epoch = epoch;\n        }\n      }\n\n      const msg = {};\n      if (this._config.protocolVersion === 'v2') {\n        msg.subscribe = req;\n      } else {\n        msg.method = this._methodType.SUBSCRIBE;\n        msg.params = req;\n      }\n\n      this._call(msg).then(resolveCtx => {\n        let result;\n        if (this._config.protocolVersion === 'v1') {\n          result = this._decoder.decodeCommandResult(this._methodType.SUBSCRIBE, resolveCtx.reply.result);\n        } else {\n          result = resolveCtx.reply.subscribe;\n        }\n        this._subscribeResponse(\n          channel,\n          recover,\n          result\n        );\n        if (resolveCtx.next) {\n          resolveCtx.next();\n        }\n      }, rejectCtx => {\n        this._subscribeError(channel, rejectCtx.error);\n        if (rejectCtx.next) {\n          rejectCtx.next();\n        }\n      });\n    }\n  };\n\n  _unsubscribe(sub) {\n    delete this._subs[sub.channel];\n    delete this._lastOffset[sub.channel];\n    delete this._lastSeq[sub.channel];\n    delete this._lastGen[sub.channel];\n    if (this.isConnected()) {\n      // No need to unsubscribe in disconnected state - i.e. client already unsubscribed.\n      const req = {\n        channel: sub.channel\n      };\n      const msg = {};\n      if (this._config.protocolVersion === 'v2') {\n        msg.unsubscribe = req;\n      } else {\n        msg.method = this._methodType.UNSUBSCRIBE;\n        msg.params = req;\n      }\n      this._addMessage(msg);\n    }\n  };\n\n  _getTTLMilliseconds(ttl) {\n    // https://stackoverflow.com/questions/12633405/what-is-the-maximum-delay-for-setinterval\n    return Math.min(ttl * 1000, 2147483647);\n  }\n\n  getSub(channel) {\n    return this._getSub(channel);\n  }\n\n  _getSub(channel) {\n    const sub = this._subs[channel];\n    if (!sub) {\n      return null;\n    }\n    return sub;\n  };\n\n  _isServerSub(channel) {\n    return this._serverSubs[channel] !== undefined;\n  };\n\n  _connectResponse(result, isRecover) {\n    const wasReconnecting = this._reconnecting;\n    this._reconnecting = false;\n    this._resetRetry();\n    this._refreshRequired = false;\n\n    if (this.isConnected()) {\n      return;\n    }\n\n    if (this._latencyStart !== null) {\n      this._latency = (new Date()).getTime() - this._latencyStart.getTime();\n      this._latencyStart = null;\n    }\n\n    this._clientID = result.client;\n    this._setStatus('connected');\n\n    if (this._refreshTimeout) {\n      clearTimeout(this._refreshTimeout);\n    }\n\n    if (result.expires) {\n      this._refreshTimeout = setTimeout(() => this._refresh(), this._getTTLMilliseconds(result.ttl));\n    }\n\n    this.startBatching();\n    this.startSubscribeBatching();\n    for (const channel in this._subs) {\n      if (this._subs.hasOwnProperty(channel)) {\n        const sub = this._subs[channel];\n        if (sub._shouldResubscribe()) {\n          this._subscribe(sub, wasReconnecting);\n        }\n      }\n    }\n    this.stopSubscribeBatching();\n    this.stopBatching();\n\n    this._startPing();\n\n    const ctx = {\n      client: result.client,\n      transport: this._transportName,\n      latency: this._latency\n    };\n    if (result.data) {\n      ctx.data = result.data;\n    }\n\n    this.emit('connect', ctx);\n\n    if (result.subs) {\n      this._processServerSubs(result.subs);\n    }\n  };\n\n  _processServerSubs(subs) {\n    for (const channel in subs) {\n      if (subs.hasOwnProperty(channel)) {\n        const sub = subs[channel];\n        const isResubscribe = this._serverSubs[channel] !== undefined;\n        let subCtx = { channel: channel, isResubscribe: isResubscribe };\n        subCtx = this._expandSubscribeContext(subCtx, sub);\n        this.emit('subscribe', subCtx);\n      }\n    }\n    for (const channel in subs) {\n      if (subs.hasOwnProperty(channel)) {\n        const sub = subs[channel];\n        if (sub.recovered) {\n          let pubs = sub.publications;\n          if (pubs && pubs.length > 0) {\n\n            // handle legacy order.\n            // TODO: remove as soon as Centrifuge v1 released.\n            if (pubs.length > 1 && (!pubs[0].offset || pubs[0].offset > pubs[1].offset)) {\n              pubs = pubs.reverse();\n            }\n\n            for (let i in pubs) {\n              if (pubs.hasOwnProperty(i)) {\n                this._handlePublication(channel, pubs[i]);\n              }\n            }\n          }\n        }\n        this._serverSubs[channel] = {\n          'seq': sub.seq,\n          'gen': sub.gen,\n          'offset': sub.offset,\n          'epoch': sub.epoch,\n          'recoverable': sub.recoverable\n        };\n      }\n    }\n  };\n\n  _stopPing() {\n    if (this._pongTimeout !== null) {\n      clearTimeout(this._pongTimeout);\n      this._pongTimeout = null;\n    }\n    if (this._pingTimeout !== null) {\n      clearTimeout(this._pingTimeout);\n      this._pingTimeout = null;\n    }\n  };\n\n  _startPing() {\n    if (this._config.ping !== true || this._config.pingInterval <= 0) {\n      return;\n    }\n    if (!this.isConnected()) {\n      return;\n    }\n\n    this._pingTimeout = setTimeout(() => {\n      if (!this.isConnected()) {\n        this._stopPing();\n        return;\n      }\n      this.ping();\n      this._pongTimeout = setTimeout(() => {\n        this._disconnect(11, 'no ping', true);\n      }, this._config.pongWaitTimeout);\n    }, this._config.pingInterval);\n  };\n\n  _restartPing() {\n    this._stopPing();\n    this._startPing();\n  };\n\n  _subscribeError(channel, error) {\n    const sub = this._getSub(channel);\n    if (!sub) {\n      return;\n    }\n    if (!sub._isSubscribing()) {\n      return;\n    }\n    if (error.code === 0 && error.message === _errorTimeout) { // client side timeout.\n      this._disconnect(10, 'subscribe timeout', true);\n      return;\n    }\n    sub._setSubscribeError(error);\n  };\n\n  _expandSubscribeContext(ctx, result) {\n    let recovered = false;\n    if ('recovered' in result) {\n      recovered = result.recovered;\n    }\n    ctx.recovered = recovered;\n\n    let positioned = false;\n    if ('positioned' in result) {\n      positioned = result.positioned;\n    }\n    let epoch = '';\n    if ('epoch' in result) {\n      epoch = result.epoch;\n    }\n    let offset = 0;\n    if ('offset' in result) {\n      offset = result.offset;\n    }\n    if (positioned) {\n      ctx.streamPosition = {\n        'offset': offset,\n        'epoch': epoch\n      };\n    };\n    if (result.data) {\n      ctx.data = result.data;\n    }\n    return ctx;\n  }\n\n  _subscribeResponse(channel, isRecover, result) {\n    const sub = this._getSub(channel);\n    if (!sub) {\n      return;\n    }\n    if (!sub._isSubscribing()) {\n      return;\n    }\n    sub._setSubscribeSuccess(result);\n\n    let pubs = result.publications;\n    if (pubs && pubs.length > 0) {\n      if (pubs.length >= 2 && !pubs[0].offset && !pubs[1].offset) {\n        // handle legacy order.\n        pubs = pubs.reverse();\n      }\n      for (let i in pubs) {\n        if (pubs.hasOwnProperty(i)) {\n          this._handlePublication(channel, pubs[i]);\n        }\n      }\n    }\n\n    if (result.recoverable && (!isRecover || !result.recovered)) {\n      this._lastSeq[channel] = result.seq || 0;\n      this._lastGen[channel] = result.gen || 0;\n      this._lastOffset[channel] = result.offset || 0;\n    }\n\n    this._lastEpoch[channel] = result.epoch || '';\n\n    if (result.recoverable) {\n      sub._recoverable = true;\n    }\n\n    if (result.expires === true) {\n      let subRefreshTimeout = setTimeout(() => this._subRefresh(channel), this._getTTLMilliseconds(result.ttl));\n      this._subRefreshTimeouts[channel] = subRefreshTimeout;\n    }\n  };\n\n  _handleReply(reply, next) {\n    const id = reply.id;\n\n    if (!(id in this._callbacks)) {\n      next();\n      return;\n    }\n    const callbacks = this._callbacks[id];\n    clearTimeout(this._callbacks[id].timeout);\n    delete this._callbacks[id];\n\n    if (!errorExists(reply)) {\n      const callback = callbacks.callback;\n      if (!callback) {\n        return;\n      }\n      callback({ reply, next });\n    } else {\n      const errback = callbacks.errback;\n      if (!errback) {\n        next();\n        return;\n      }\n      const error = reply.error;\n      errback({ error, next });\n    }\n  }\n\n  _handleJoin(channel, join) {\n    const ctx = { 'info': join.info };\n    const sub = this._getSub(channel);\n    if (!sub) {\n      if (this._isServerSub(channel)) {\n        ctx.channel = channel;\n        this.emit('join', ctx);\n      }\n      return;\n    }\n    sub.emit('join', ctx);\n  };\n\n  _handleLeave(channel, leave) {\n    const ctx = { 'info': leave.info };\n    const sub = this._getSub(channel);\n    if (!sub) {\n      if (this._isServerSub(channel)) {\n        ctx.channel = channel;\n        this.emit('leave', ctx);\n      }\n      return;\n    }\n    sub.emit('leave', ctx);\n  };\n\n  _handleUnsub(channel, unsub) {\n    const ctx = {};\n    const sub = this._getSub(channel);\n    if (!sub) {\n      if (this._isServerSub(channel)) {\n        delete this._serverSubs[channel];\n        ctx.channel = channel;\n        this.emit('unsubscribe', ctx);\n      }\n      return;\n    }\n    sub.unsubscribe();\n    if (unsub.resubscribe === true) {\n      sub.subscribe();\n    }\n  };\n\n  _handleSub(channel, sub) {\n    this._serverSubs[channel] = {\n      'seq': sub.seq,\n      'gen': sub.gen,\n      'offset': sub.offset,\n      'epoch': sub.epoch,\n      'recoverable': sub.recoverable\n    };\n    let ctx = { 'channel': channel, isResubscribe: false };\n    ctx = this._expandSubscribeContext(ctx, sub);\n    this.emit('subscribe', ctx);\n  };\n\n  _handlePublication(channel, pub) {\n    const sub = this._getSub(channel);\n    const ctx = {\n      'data': pub.data,\n      'seq': pub.seq,\n      'gen': pub.gen,\n      'offset': pub.offset\n    };\n    if (pub.info) {\n      ctx.info = pub.info;\n    }\n    if (pub.meta) {\n      ctx.meta = pub.meta;\n    }\n    if (!sub) {\n      if (this._isServerSub(channel)) {\n        if (pub.seq !== undefined) {\n          this._serverSubs[channel].seq = pub.seq;\n        }\n        if (pub.gen !== undefined) {\n          this._serverSubs[channel].gen = pub.gen;\n        }\n        if (pub.offset !== undefined) {\n          this._serverSubs[channel].offset = pub.offset;\n        }\n        ctx.channel = channel;\n        this.emit('publish', ctx);\n      }\n      return;\n    }\n    if (pub.seq !== undefined) {\n      this._lastSeq[channel] = pub.seq;\n    }\n    if (pub.gen !== undefined) {\n      this._lastGen[channel] = pub.gen;\n    }\n    if (pub.offset !== undefined) {\n      this._lastOffset[channel] = pub.offset;\n    }\n    sub.emit('publish', ctx);\n  };\n\n  _handleMessage(message) {\n    this.emit('message', message.data);\n  };\n\n  _handlePush(data, next) {\n    const push = this._decoder.decodePush(data);\n    let type = 0;\n    if ('type' in push) {\n      type = push['type'];\n    }\n    const channel = push.channel;\n\n    if (type === this._pushType.PUBLICATION) {\n      const pub = this._decoder.decodePushData(this._pushType.PUBLICATION, push.data);\n      this._handlePublication(channel, pub);\n    } else if (type === this._pushType.MESSAGE) {\n      const message = this._decoder.decodePushData(this._pushType.MESSAGE, push.data);\n      this._handleMessage(message);\n    } else if (type === this._pushType.JOIN) {\n      const join = this._decoder.decodePushData(this._pushType.JOIN, push.data);\n      this._handleJoin(channel, join);\n    } else if (type === this._pushType.LEAVE) {\n      const leave = this._decoder.decodePushData(this._pushType.LEAVE, push.data);\n      this._handleLeave(channel, leave);\n    } else if (type === this._pushType.UNSUBSCRIBE) {\n      const unsub = this._decoder.decodePushData(this._pushType.UNSUBSCRIBE, push.data);\n      this._handleUnsub(channel, unsub);\n    } else if (type === this._pushType.SUBSCRIBE) {\n      const sub = this._decoder.decodePushData(this._pushType.UNSUBSCRIBE, push.data);\n      this._handleSub(channel, sub);\n    }\n    next();\n  }\n\n  _handlePushV2(data, next) {\n    const channel = data.channel;\n    if (data.pub) {\n      this._handlePublication(channel, data.pub);\n    } else if (data.message) {\n      this._handleMessage(data.message);\n    } else if (data.join) {\n      this._handleJoin(channel, data.join);\n    } else if (data.leave) {\n      this._handleLeave(channel, data.leave);\n    } else if (data.unsubscribe) {\n      this._handleUnsub(channel, data.unsubscribe);\n    } else if (data.subscribe) {\n      this._handleSub(channel, data.subscribe);\n    }\n    next();\n  }\n\n  _flush() {\n    const messages = this._messages.slice(0);\n    this._messages = [];\n    this._transportSend(messages);\n  };\n\n  _ping() {\n    const msg = {};\n    if (this._config.protocolVersion === 'v2') {\n      // v2 does not require any additional data for pings;\n    } else {\n      msg.method = this._methodType.PING;\n    }\n    this._call(msg).then(resolveCtx => {\n      this._pingResponse(this._decoder.decodeCommandResult(this._methodType.PING, resolveCtx.result));\n      if (resolveCtx.next) {\n        resolveCtx.next();\n      }\n    }, rejectCtx => {\n      this._debug('ping error', rejectCtx.error);\n      if (rejectCtx.next) {\n        rejectCtx.next();\n      }\n    });\n  };\n\n  _pingResponse(result) {\n    if (!this.isConnected()) {\n      return;\n    }\n    this._stopPing();\n    this._startPing();\n  }\n\n  _getLastSeq(channel) {\n    const lastSeq = this._lastSeq[channel];\n    if (lastSeq) {\n      return lastSeq;\n    }\n    return 0;\n  };\n\n  _getLastOffset(channel) {\n    const lastOffset = this._lastOffset[channel];\n    if (lastOffset) {\n      return lastOffset;\n    }\n    return 0;\n  };\n\n  _getLastGen(channel) {\n    const lastGen = this._lastGen[channel];\n    if (lastGen) {\n      return lastGen;\n    }\n    return 0;\n  };\n\n  _getLastEpoch(channel) {\n    const lastEpoch = this._lastEpoch[channel];\n    if (lastEpoch) {\n      return lastEpoch;\n    }\n    return '';\n  };\n\n  _createErrorObject(message, code) {\n    const errObject = {\n      message: message,\n      code: code || 0\n    };\n\n    return errObject;\n  };\n\n  _registerCall(id, callback, errback) {\n    this._callbacks[id] = {\n      callback: callback,\n      errback: errback,\n      timeout: null\n    };\n    this._callbacks[id].timeout = setTimeout(() => {\n      delete this._callbacks[id];\n      if (isFunction(errback)) {\n        errback({ error: this._createErrorObject(_errorTimeout) });\n      }\n    }, this._config.timeout);\n  };\n\n  _addMessage(message) {\n    let id = this._nextMessageId();\n    message.id = id;\n    if (this._isBatching === true) {\n      this._messages.push(message);\n    } else {\n      this._transportSend([message]);\n    }\n    return id;\n  };\n\n  isConnected() {\n    return this._isConnected();\n  }\n\n  connect() {\n    this._connect();\n  };\n\n  disconnect() {\n    this._disconnect(0, 'client', false);\n  };\n\n  ping() {\n    return this._ping();\n  }\n\n  startBatching() {\n    // start collecting messages without sending them to Centrifuge until flush\n    // method called\n    this._isBatching = true;\n  };\n\n  stopBatching() {\n    this._isBatching = false;\n    this._flush();\n  };\n\n  startSubscribeBatching() {\n    // start collecting private channels to create bulk authentication\n    // request to subscribeEndpoint when stopSubscribeBatching will be called\n    this._isSubscribeBatching = true;\n  };\n\n  stopSubscribeBatching() {\n    // create request to subscribeEndpoint with collected private channels\n    // to ask if this client can subscribe on each channel\n    this._isSubscribeBatching = false;\n    const authChannels = this._privateChannels;\n    this._privateChannels = {};\n\n    const channels = [];\n\n    for (const channel in authChannels) {\n      if (authChannels.hasOwnProperty(channel)) {\n        const sub = this._getSub(channel);\n        if (!sub) {\n          continue;\n        }\n        channels.push(channel);\n      }\n    }\n\n    if (channels.length === 0) {\n      this._debug('no private channels found, no need to make request');\n      return;\n    }\n\n    const data = {\n      client: this._clientID,\n      channels: channels\n    };\n\n    const clientID = this._clientID;\n    const xhrID = this._newXHRID();\n\n    const cb = (resp) => {\n      if (xhrID in this._xhrs) {\n        delete this._xhrs[xhrID];\n      }\n      if (this._clientID !== clientID) {\n        return;\n      }\n      if (resp.error || resp.status !== 200) {\n        this._debug('authorization request failed');\n        for (const i in channels) {\n          if (channels.hasOwnProperty(i)) {\n            const channel = channels[i];\n            this._subscribeError(channel, this._createErrorObject('authorization request failed'));\n          }\n        }\n        return;\n      }\n\n      let channelsData = {};\n      if (resp.data.channels) {\n        for (const i in resp.data.channels) {\n          const channelData = resp.data.channels[i];\n          if (!channelData.channel) {\n            continue;\n          }\n          channelsData[channelData.channel] = channelData.token;\n        }\n      }\n\n      // try to send all subscriptions in one request.\n      let batch = false;\n\n      if (!this._isBatching) {\n        this.startBatching();\n        batch = true;\n      }\n\n      for (const i in channels) {\n        if (channels.hasOwnProperty(i)) {\n          const channel = channels[i];\n          const token = channelsData[channel];\n\n          if (!token) {\n            // subscription:error\n            this._subscribeError(channel, this._createErrorObject('permission denied', 103));\n            continue;\n          } else {\n            const sub = this._getSub(channel);\n            if (sub === null) {\n              continue;\n            }\n\n            const req = {\n              channel: channel,\n              token: token\n            };\n\n            const recover = sub._needRecover();\n\n            if (recover === true) {\n              req.recover = true;\n              const seq = this._getLastSeq(channel);\n              const gen = this._getLastGen(channel);\n              if (seq || gen) {\n                if (seq) {\n                  req.seq = seq;\n                }\n                if (gen) {\n                  req.gen = gen;\n                }\n              } else {\n                const offset = this._getLastOffset(channel);\n                if (offset) {\n                  req.offset = offset;\n                }\n              }\n              const epoch = this._getLastEpoch(channel);\n              if (epoch) {\n                req.epoch = epoch;\n              }\n            }\n            const msg = {};\n            if (this._config.protocolVersion === 'v2') {\n              msg.subscribe = req;\n            } else {\n              msg.method = this._methodType.SUBSCRIBE;\n              msg.params = req;\n            }\n            this._call(msg).then(resolveCtx => {\n              let result;\n              if (this._config.protocolVersion === 'v1') {\n                result = this._decoder.decodeCommandResult(this._methodType.SUBSCRIBE, resolveCtx.reply.result);\n              } else {\n                result = resolveCtx.reply.subscribe;\n              }\n              this._subscribeResponse(\n                channel,\n                recover,\n                result\n              );\n              if (resolveCtx.next) {\n                resolveCtx.next();\n              }\n            }, rejectCtx => {\n              this._subscribeError(channel, rejectCtx.error);\n              if (rejectCtx.next) {\n                rejectCtx.next();\n              }\n            });\n          }\n        }\n      }\n\n      if (batch) {\n        this.stopBatching();\n      }\n\n    };\n\n    if (this._config.onPrivateSubscribe !== null) {\n      this._config.onPrivateSubscribe({\n        data: data\n      }, cb);\n    } else {\n      const xhr = this._ajax(\n        this._config.subscribeEndpoint, this._config.subscribeParams, this._config.subscribeHeaders, data, cb);\n      this._xhrs[xhrID] = xhr;\n    }\n  };\n\n  _setSubscribeSince(sub, since) {\n    this._lastOffset[sub.channel] = since.offset;\n    this._lastEpoch[sub.channel] = since.epoch;\n    sub._setNeedRecover(true);\n  }\n\n  subscribe(channel, events, opts) {\n    const currentSub = this._getSub(channel);\n    if (currentSub !== null) {\n      currentSub._setEvents(events);\n      if (currentSub._isUnsubscribed()) {\n        currentSub.subscribe(opts);\n      }\n      return currentSub;\n    }\n    const sub = new Subscription(this, channel, events);\n    this._subs[channel] = sub;\n    sub.subscribe(opts);\n    return sub;\n  };\n}\n","import { Centrifuge } from './centrifuge.js';\nexport default Centrifuge;\n","export const JsonMethodType = {\n  CONNECT: 0,\n  SUBSCRIBE: 1,\n  UNSUBSCRIBE: 2,\n  PUBLISH: 3,\n  PRESENCE: 4,\n  PRESENCE_STATS: 5,\n  HISTORY: 6,\n  PING: 7,\n  SEND: 8,\n  RPC: 9,\n  REFRESH: 10,\n  SUB_REFRESH: 11\n};\n\nexport const JsonPushType = {\n  PUBLICATION: 0,\n  JOIN: 1,\n  LEAVE: 2,\n  UNSUBSCRIBE: 3,\n  MESSAGE: 4,\n  SUBSCRIBE: 5\n};\n\nexport class JsonEncoder {\n  encodeCommands(commands) {\n    return commands.map(c => JSON.stringify(c)).join('\\n');\n  }\n}\n\nexport class JsonDecoder {\n  decodeReplies(data) {\n    return data.split('\\n').filter(r => r !== '').map(r => JSON.parse(r));\n  }\n\n  decodeCommandResult(methodType, data) {\n    return data;\n  }\n\n  decodePush(data) {\n    return data;\n  }\n\n  decodePushData(pushType, data) {\n    return data;\n  }\n}\n\n","import EventEmitter from 'events';\n\nimport {\n  isFunction\n} from './utils';\n\nconst _STATE_NEW = 0;\nconst _STATE_SUBSCRIBING = 1;\nconst _STATE_SUCCESS = 2;\nconst _STATE_ERROR = 3;\nconst _STATE_UNSUBSCRIBED = 4;\n\nexport default class Subscription extends EventEmitter {\n  constructor(centrifuge, channel, events) {\n    super();\n    this.channel = channel;\n    this._centrifuge = centrifuge;\n    this._status = _STATE_NEW;\n    this._error = null;\n    this._isResubscribe = false;\n    this._ready = false;\n    this._subscriptionPromise = null;\n    this._noResubscribe = false;\n    this._recoverable = false;\n    this._recover = false;\n    this._setEvents(events);\n    this._initializePromise();\n    this._promises = {};\n    this._promiseId = 0;\n    this._subscribeData = null;\n    this._autoResubscribeErrorCodes = [];\n    this._autoResubscribeMinDelay = 500;\n    this._autoResubscribeMaxDelay = 20000;\n    this._resubscribeTimeout = null;\n    this._resubscribeAttempts = 0;\n\n    this.on('error', function (errContext) {\n      this._centrifuge._debug('subscription error', errContext);\n    });\n  }\n\n  _nextPromiseId() {\n    return ++this._promiseId;\n  }\n\n  _initializePromise() {\n    // this helps us to wait until subscription will successfully\n    // subscribe and call actions such as presence, history etc in\n    // synchronous way.\n    this._ready = false;\n\n    this._subscriptionPromise = new Promise((resolve, reject) => {\n      this._resolve = value => {\n        this._ready = true;\n        resolve(value);\n      };\n      this._reject = err => {\n        this._ready = true;\n        reject(err);\n      };\n    }).then(function () { }, function () { });\n  };\n\n  _setNeedRecover(enabled) {\n    this._recoverable = enabled;\n    this._recover = enabled;\n  }\n\n  _needRecover() {\n    return this._recoverable === true && this._recover === true;\n  };\n\n  _setEvents(events) {\n    if (!events) {\n      return;\n    }\n    if (isFunction(events)) {\n      // events is just a function to handle publication received from channel.\n      this.on('publish', events);\n    } else if (Object.prototype.toString.call(events) === Object.prototype.toString.call({})) {\n      const knownEvents = ['publish', 'join', 'leave', 'unsubscribe', 'subscribe', 'error'];\n      for (let i = 0, l = knownEvents.length; i < l; i++) {\n        const ev = knownEvents[i];\n        if (ev in events) {\n          this.on(ev, events[ev]);\n        }\n      }\n    }\n  };\n\n  _isNew() {\n    return this._status === _STATE_NEW;\n  };\n\n  _isUnsubscribed() {\n    return this._status === _STATE_UNSUBSCRIBED;\n  };\n\n  _isSubscribing() {\n    return this._status === _STATE_SUBSCRIBING;\n  };\n\n  _isReady() {\n    return this._status === _STATE_SUCCESS || this._status === _STATE_ERROR;\n  };\n\n  _isSuccess() {\n    return this._status === _STATE_SUCCESS;\n  };\n\n  _isError() {\n    return this._status === _STATE_ERROR;\n  };\n\n  _setNew() {\n    this._status = _STATE_NEW;\n  };\n\n  _setSubscribing(isResubscribe) {\n    this._isResubscribe = isResubscribe || false;\n    if (this._ready === true) {\n      // new promise for this subscription\n      this._initializePromise();\n    }\n    this._status = _STATE_SUBSCRIBING;\n  };\n\n  _setSubscribeSuccess(subscribeResult) {\n    if (this._status === _STATE_SUCCESS) {\n      return;\n    }\n    this._status = _STATE_SUCCESS;\n    this._resubscribeAttempts = 0;\n    const successContext = this._getSubscribeSuccessContext(subscribeResult);\n    this._recover = false;\n    this.emit('subscribe', successContext);\n    this._resolve(successContext);\n    for (const id in this._promises) {\n      clearTimeout(this._promises[id].timeout);\n      this._promises[id].resolve();\n      delete this._promises[id];\n    }\n  };\n\n  _setSubscribeError(err) {\n    if (this._status === _STATE_ERROR) {\n      return;\n    }\n    this._status = _STATE_ERROR;\n    this._error = err;\n    const errContext = this._getSubscribeErrorContext();\n    this.emit('error', errContext);\n    this._reject(errContext);\n    for (const id in this._promises) {\n      clearTimeout(this._promises[id].timeout);\n      this._promises[id].reject(err);\n      delete this._promises[id];\n    }\n\n    if (this._autoResubscribeErrorCodes.indexOf(err.code) > -1) {\n      this._resubscribeAttempts++;\n      const self = this;\n      const jitter = Math.round(Math.random() * this._autoResubscribeMinDelay);\n      this._resubscribeTimeout = setTimeout(function () {\n        self.subscribe();\n      }, Math.min(\n        this._autoResubscribeMaxDelay,\n        Math.pow(this._resubscribeAttempts, 2) * this._autoResubscribeMinDelay + jitter)\n      );\n    }\n  };\n\n  _triggerUnsubscribe() {\n    this.emit('unsubscribe', {\n      channel: this.channel\n    });\n  };\n\n  _setUnsubscribed(noResubscribe) {\n    this._resubscribeAttempts = 0;\n    clearTimeout(this._resubscribeTimeout);\n    this._centrifuge._clearSubRefreshTimeout(this.channel);\n    if (this._status === _STATE_UNSUBSCRIBED) {\n      return;\n    }\n    const needTrigger = this._status === _STATE_SUCCESS;\n    this._status = _STATE_UNSUBSCRIBED;\n    if (noResubscribe === true) {\n      this._recover = false;\n      this._noResubscribe = true;\n      delete this._centrifuge._lastSeq[this.channel];\n      delete this._centrifuge._lastGen[this.channel];\n      delete this._centrifuge._lastEpoch[this.channel];\n    }\n    if (needTrigger) {\n      this._triggerUnsubscribe();\n    }\n  };\n\n  _shouldResubscribe() {\n    return !this._noResubscribe;\n  };\n\n  _getSubscribeSuccessContext(subscribeResult) {\n    let ctx = {\n      channel: this.channel,\n      isResubscribe: this._isResubscribe\n    };\n    if (subscribeResult) {\n      // subscribeResult not available when called from Subscription.ready method at the moment.\n      ctx = this._centrifuge._expandSubscribeContext(ctx, subscribeResult);\n    }\n    return ctx;\n  };\n\n  _getSubscribeErrorContext() {\n    const subscribeErrorContext = this._error;\n    subscribeErrorContext.channel = this.channel;\n    subscribeErrorContext.isResubscribe = this._isResubscribe;\n    return subscribeErrorContext;\n  };\n\n  _setSubscribeData(data) {\n    this._subscribeData = data;\n  }\n\n  _setAutoResubscribe(opts) {\n    this._autoResubscribeErrorCodes = opts.autoResubscribeErrorCodes;\n    if (opts.autoResubscribeMinDelay) {\n      this._autoResubscribeMinDelay = opts.autoResubscribeMinDelay;\n    }\n    if (opts.autoResubscribeMaxDelay) {\n      this._autoResubscribeMaxDelay = opts.autoResubscribeMaxDelay;\n    }\n  }\n\n  ready(callback, errback) {\n    if (this._ready) {\n      if (this._isSuccess()) {\n        callback(this._getSubscribeSuccessContext());\n      } else {\n        errback(this._getSubscribeErrorContext());\n      }\n    }\n  };\n\n  subscribe(opts) {\n    if (this._status === _STATE_SUCCESS) {\n      return;\n    }\n    if (opts && opts.since) {\n      this._centrifuge._setSubscribeSince(this, opts.since);\n    }\n    if (opts && opts.data) {\n      this._setSubscribeData(opts.data);\n    }\n    if (opts && opts.autoResubscribeErrorCodes && opts.autoResubscribeErrorCodes.length > 0) {\n      this._setAutoResubscribe(opts);\n    }\n    this._noResubscribe = false;\n    this._centrifuge._subscribe(this);\n  };\n\n  unsubscribe() {\n    this._setUnsubscribed(true);\n    this._centrifuge._unsubscribe(this);\n  };\n\n  _methodCall() {\n    if (this._isSuccess()) {\n      return Promise.resolve();\n    } else if (this._isError()) {\n      return Promise.reject(this._error);\n    }\n    let subPromise = new Promise((res, rej) => {\n      const timeout = setTimeout(function () {\n        rej({ 'code': 0, 'message': 'timeout' });\n      }, this._centrifuge._config.timeout);\n      this._promises[this._nextPromiseId()] = {\n        timeout: timeout,\n        resolve: res,\n        reject: rej\n      };\n    });\n    return subPromise;\n  }\n\n  publish(data) {\n    const self = this;\n    return this._methodCall().then(function () {\n      return self._centrifuge.publish(self.channel, data);\n    });\n  };\n\n  presence() {\n    const self = this;\n    return this._methodCall().then(function () {\n      return self._centrifuge.presence(self.channel);\n    });\n  };\n\n  presenceStats() {\n    const self = this;\n    return this._methodCall().then(function () {\n      return self._centrifuge.presenceStats(self.channel);\n    });\n  };\n\n  history(options) {\n    const self = this;\n    return this._methodCall().then(function () {\n      return self._centrifuge.history(self.channel, options);\n    });\n  };\n}\n","export function startsWith(value, prefix) {\n  return value.lastIndexOf(prefix, 0) === 0;\n};\n\nexport function isFunction(value) {\n  if (value === undefined || value === null) {\n    return false;\n  }\n  return typeof value === 'function';\n};\n\nexport function log(level, args) {\n  if (global.console) {\n    const logger = global.console[level];\n\n    if (isFunction(logger)) {\n      logger.apply(global.console, args);\n    }\n  }\n};\n\nexport function backoff(step, min, max) {\n  const jitter = 0.5 * Math.random();\n  const interval = Math.min(max, min * Math.pow(2, step + 1));\n\n  return Math.floor((1 - jitter) * interval);\n};\n\nexport function errorExists(data) {\n  return 'error' in data && data.error !== null;\n};\n\nexport function extend(a, b) {\n  for (const key in b) {\n    if (b.hasOwnProperty(key)) {\n      a[key] = b[key];\n    }\n  }\n  return a;\n};\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(579);\n"],"names":["root","factory","exports","module","define","amd","this","_errorTimeout","_errorConnectionClosed","Centrifuge","url","options","_url","_websocket","_sockjs","_isSockjs","_xmlhttprequest","_binary","_methodType","_pushType","_encoder","_decoder","_status","_reconnect","_reconnecting","_transport","_transportName","_transportClosed","_messageId","_clientID","_refreshRequired","_subs","_serverSubs","_lastSeq","_lastGen","_lastOffset","_lastEpoch","_messages","_isBatching","_isSubscribeBatching","_privateChannels","_numRefreshFailed","_refreshTimeout","_pingTimeout","_pongTimeout","_subRefreshTimeouts","_retries","_callbacks","_latency","_latencyStart","_connectData","_token","_xhrID","_xhrs","_dispatchPromise","Promise","resolve","_protocol","_config","protocol","protocolVersion","debug","name","version","websocket","sockjs","xmlhttprequest","minRetry","maxRetry","timeout","ping","pingInterval","pongWaitTimeout","privateChannelPrefix","onTransportClose","sockjsServer","sockjsTimeout","sockjsTransports","refreshEndpoint","refreshHeaders","refreshParams","refreshData","refreshAttempts","refreshInterval","onRefreshFailed","onRefresh","subscribeEndpoint","subscribeHeaders","subscribeParams","subRefreshInterval","onPrivateSubscribe","disableWithCredentials","_configure","token","data","headers","params","callback","xhr","query","i","_debug","JSON","stringify","global","XMLHttpRequest","ActiveXObject","hasOwnProperty","length","encodeURIComponent","headerName","open","withCredentials","setRequestHeader","onreadystatechange","readyState","status","parsed","parse","responseText","e","error","_log","setTimeout","send","log","arguments","WebSocket","format","_formatOverride","Error","JsonMethodType","JsonPushType","JsonEncoder","JsonDecoder","configuration","extend","startsWith","indexOf","_setFormat","SockJS","newStatus","interval","backoff","xhrID","abort","reconnect","id","_stopPing","callbacks","clearTimeout","errback","_createErrorObject","channel","sub","_isSuccess","_triggerUnsubscribe","_recover","_shouldResubscribe","_setSubscribing","_setUnsubscribed","_abortInflightXHRs","_clearSubRefreshTimeout","transport","OPEN","commands","_isTransportOpen","command","encodeCommands","sockjsOptions","transports","server","_websocketSupported","subProtocol","_getSubProtocol","binaryType","onopen","onheartbeat","_restartPing","req","subs","hasSubs","recoverable","seq","gen","offset","epoch","Date","msg","connect","_call","then","resolveCtx","result","decodeCommandResult","CONNECT","reply","_connectResponse","next","rejectCtx","code","_disconnect","onerror","onclose","closeEvent","reason","needReconnect","advice","ctx","event","_getRetryInterval","_refresh","_connect","onmessage","_dataReceived","_rpc","method","rpc","RPC","self","_methodCall","SEND","isConnected","_transportSend","reject","undefined","since","limit","reverse","resultCB","publish","PUBLISH","_getHistoryRequest","history","HISTORY","publications","presence","PRESENCE","PRESENCE_STATS","presence_stats","num_users","num_clients","replies","decodeReplies","finishDispatch","_dispatchSynchronized","p","_dispatchReply","_handleReply","_handlePush","_handlePushV2","push","_addMessage","_registerCall","_setStatus","_setupTransport","shouldReconnect","_isDisconnected","_clearConnectedState","emit","close","_refreshFailed","clientID","_newXHRID","cb","resp","jitter","Math","round","random","max","refresh","REFRESH","_refreshResponse","_refreshError","_ajax","err","expires","client","_getTTLMilliseconds","ttl","channelsData","channels","channelData","_getSub","SUB_REFRESH","sub_refresh","_subRefreshResponse","_subRefreshError","subRefreshTimeout","_subRefresh","isResubscribe","_subscribeData","startSubscribeBatching","_subscribe","stopSubscribeBatching","recover","_needRecover","_getLastSeq","_getLastGen","_getLastOffset","_getLastEpoch","subscribe","SUBSCRIBE","_subscribeResponse","_subscribeError","_setNew","unsubscribe","UNSUBSCRIBE","min","isRecover","wasReconnecting","_resetRetry","getTime","startBatching","stopBatching","_startPing","latency","_processServerSubs","subCtx","_expandSubscribeContext","recovered","pubs","_handlePublication","_isSubscribing","message","_setSubscribeError","positioned","streamPosition","_setSubscribeSuccess","_recoverable","errorExists","join","info","_isServerSub","leave","unsub","resubscribe","pub","meta","decodePush","type","PUBLICATION","decodePushData","MESSAGE","_handleMessage","JOIN","_handleJoin","LEAVE","_handleLeave","_handleUnsub","_handleSub","messages","slice","PING","_pingResponse","isFunction","_nextMessageId","_isConnected","_ping","_flush","authChannels","batch","_setNeedRecover","events","opts","currentSub","_setEvents","_isUnsubscribed","Subscription","EventEmitter","map","c","split","filter","r","methodType","pushType","centrifuge","_centrifuge","_error","_isResubscribe","_ready","_subscriptionPromise","_noResubscribe","_initializePromise","_promises","_promiseId","_autoResubscribeErrorCodes","_autoResubscribeMinDelay","_autoResubscribeMaxDelay","_resubscribeTimeout","_resubscribeAttempts","on","errContext","_resolve","value","_reject","enabled","Object","prototype","toString","call","knownEvents","l","ev","subscribeResult","successContext","_getSubscribeSuccessContext","_getSubscribeErrorContext","pow","noResubscribe","needTrigger","subscribeErrorContext","autoResubscribeErrorCodes","autoResubscribeMinDelay","autoResubscribeMaxDelay","_setSubscribeSince","_setSubscribeData","_setAutoResubscribe","_unsubscribe","_isError","res","rej","_nextPromiseId","presenceStats","step","floor","a","b","key","level","args","console","logger","apply","prefix","lastIndexOf","ReflectOwnKeys","R","Reflect","ReflectApply","target","receiver","Function","ownKeys","getOwnPropertySymbols","getOwnPropertyNames","concat","NumberIsNaN","Number","isNaN","init","once","emitter","errorListener","removeListener","resolver","eventTargetAgnosticAddListener","handler","flags","addErrorHandlerIfEventEmitter","_events","_eventsCount","_maxListeners","defaultMaxListeners","checkListener","listener","TypeError","_getMaxListeners","that","_addListener","prepend","m","existing","warning","create","newListener","unshift","warned","w","String","count","warn","onceWrapper","fired","wrapFn","_onceWrap","state","wrapped","bind","_listeners","unwrap","evlistener","arr","ret","Array","unwrapListeners","arrayClone","listenerCount","n","copy","addEventListener","wrapListener","arg","removeEventListener","defineProperty","enumerable","get","set","RangeError","getPrototypeOf","setMaxListeners","getMaxListeners","doError","er","context","len","listeners","addListener","prependListener","prependOnceListener","list","position","originalListener","shift","index","pop","spliceOne","off","removeAllListeners","keys","rawListeners","eventNames","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","g","globalThis","window"],"sourceRoot":""}